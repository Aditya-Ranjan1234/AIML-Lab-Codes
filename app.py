import streamlit as st
import os
import pandas as pd
from algorithms import (
    a_star_algorithm,
    k_means_algorithm,
    knn_algorithm,
    logistic_regression_algorithm,
    naive_bayes_algorithm,
    decision_tree_algorithm
)

# Set page configuration
st.set_page_config(
    page_title="AI & ML Lab Codes",
    page_icon="ðŸ§ ",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Title and introduction
st.title("AI & ML Lab Codes Collection")
st.markdown("""
This app provides easy access to all the AI and ML lab codes.
You can view, copy, and download the code for each algorithm.
""")

# Define the algorithms and their code
algorithms = {
    "Alpha-Beta Pruning": {
        "code": """MAX, MIN = 1000, -1000

# Returns optimal value for current player
def minimax(depth, node, maximizingPlayer, values, alpha, beta):

    # leaf node is reached
    if depth == 3:
        return values[node]

    if maximizingPlayer:
        best = MIN

        # Recur for left and right children
        for i in range(0, 2):
            val = minimax(depth + 1, node * 2 + i, False, values, alpha, beta)
            best = max(best, val)
            alpha = max(alpha, best)
            if beta <= alpha:
                break
        return best

    else:
        best = MAX

        # Recur for left and right children
        for i in range(0, 2):
            val = minimax(depth + 1, node * 2 + i, True, values, alpha, beta)
            best = min(best, val)
            beta = min(beta, best)

            # Alpha Beta Pruning
            if beta <= alpha:
                break
        return best


values = [3,5,6,9,1,2,0,-1]
print("The optimal value is :", minimax(0, 0, True, values, MIN, MAX))""",
        "description": "Implementation of the Alpha-Beta Pruning algorithm for game trees."
    },

    "Hill Climbing": {
        "code": """import matplotlib.pyplot as plt
import numpy as np

# lo=input("enter the poly")

def f(x):
    # return eval(lo)
    return -x**2


def hill_climbing(initial_x, max_iterations=1000, step_size=0.9):
    current_x = initial_x
    iteration = 0
    current_value = f(current_x)

    x_values = [current_x]
    y_values = [f(current_x)]

    while iteration < max_iterations:
        neighbor_x = current_x + step_size * np.random.uniform(-1,1)

        neighbor_value = f(neighbor_x)

        if neighbor_value > current_value:
            current_x = neighbor_x
            current_value = neighbor_value
            x_values.append(current_x)
            y_values.append(current_value)

        iteration += 1

    return current_x, f(current_x), x_values, y_values


initial_x = float(input("Enter the initial value for x: "))

best_solution, best_value, x_values, y_values = hill_climbing(initial_x)

print(f"x = {best_solution}")
print(f"f(x) = {best_value}")

# Generate original function curve
original_x_values = np.linspace(min(x_values), max(x_values), 1000)
original_y_values = [f(x) for x in original_x_values]

# Plot both original function curve and points generated by hill climbing
plt.plot(original_x_values, original_y_values)
plt.plot(x_values, y_values)
plt.title("Hill Climbing Algorithm")
plt.xlabel("x")
plt.ylabel("f(x)")
# plt.legend()
plt.show()""",
        "description": "Implementation of the Hill Climbing optimization algorithm."
    },

    "Tic-Tac-Toe with Minimax": {
        "code": """def printBoard():
    print(board[1] , '|' , board[2] , '|' + board[3])
    # print('-+-+-')
    print(board[4] , '|' , board[5] , '|' + board[6])
    # print('-+-+-')
    print(board[7] , '|' , board[8] , '|' + board[9])
    # print("\\n")


def spaceIsFree(position):
    if board[position] == ' ':
        return True
    else:
        return False


def insertLetter(letter, position):
    if spaceIsFree(position):
        board[position] = letter
        printBoard()
        if checkDraw():
            print("Draw!")
            exit()
        if checkForWin():
            if letter == 'X':
                print("Bot wins!")
                exit()
            else:
                print("Player wins!")
                exit()

        return

    else:
        print("Can't insert there!")
        position = int(input("Please enter new position:  "))
        insertLetter(letter, position)
        return


def checkForWin():
    winning_combinations = [
        [1, 2, 3], [4, 5, 6], [7, 8, 9],  # Rows
        [1, 4, 7], [2, 5, 8], [3, 6, 9],  # Columns
        [1, 5, 9], [7, 5, 3]              # Diagonals
    ]

    for combo in winning_combinations:
        if board[combo[0]] == board[combo[1]] == board[combo[2]] and board[combo[0]] != ' ':
            return True

    return False


def checkWhichMarkWon(mark):
    winning_combinations = [
        [1, 2, 3], [4, 5, 6], [7, 8, 9],  # Rows
        [1, 4, 7], [2, 5, 8], [3, 6, 9],  # Columns
        [1, 5, 9], [7, 5, 3]              # Diagonals
    ]

    for combo in winning_combinations:
        if board[combo[0]] == board[combo[1]] == board[combo[2]] and board[combo[0]] == mark:
            return True

    return False


def checkDraw():
    for key in board.keys():
        if (board[key] == ' '):
            return False
    return True


def playerMove():
    position = int(input("Enter the position for 'O':  "))
    insertLetter(player, position)
    return


def compMove():
    bestScore = -800
    bestMove = None
    for key in board.keys():
        if (board[key] == ' '):
            board[key] = bot
            score = minimax(board, False)
            board[key] = ' '
            if (score > bestScore):
                bestScore = score
                bestMove = key

    if bestMove is not None:
        insertLetter(bot, bestMove)
    else:
        print("No valid moves left. It's a draw!")
        exit()
    return


def minimax(board, isMaximizing):
    if (checkWhichMarkWon(bot)):
        return 1
    if (checkWhichMarkWon(player)):
        return -1
    if (checkDraw()):
        return 0

    if (isMaximizing):
        bestScore = -800
        for key in board.keys():
            if (board[key] == ' '):
                board[key] = bot
                score = minimax(board, False)
                board[key] = ' '
                if (score > bestScore):
                    bestScore = score
        return bestScore

    else:
        bestScore = 800
        for key in board.keys():
            if (board[key] == ' '):
                board[key] = player
                score = minimax(board, True)
                board[key] = ' '
                if (score < bestScore):
                    bestScore = score
        return bestScore


board = {1: ' ', 2: ' ', 3: ' ',
         4: ' ', 5: ' ', 6: ' ',
         7: ' ', 8: ' ', 9: ' '}

printBoard()
print("Player goes first! Good luck.")
print("Positions are as follow:")
print("1, 2, 3 ")
print("4, 5, 6 ")
print("7, 8, 9 ")
print("\\n")
player = 'O'
bot = 'X'

while not checkForWin():
    playerMove()
    if checkForWin():
        break
    compMove()""",
        "description": "Implementation of a Tic-Tac-Toe game with Minimax algorithm for AI opponent."
    },

    "A* Algorithm": {
        "code": a_star_algorithm,
        "description": "Implementation of the A* pathfinding algorithm, which efficiently finds the shortest path between two points."
    },

    "K-Means Clustering": {
        "code": k_means_algorithm,
        "description": "Implementation of the K-Means clustering algorithm for unsupervised learning."
    },

    "K-Nearest Neighbors (KNN)": {
        "code": knn_algorithm,
        "description": "Implementation of the K-Nearest Neighbors algorithm for classification."
    },

    "Logistic Regression": {
        "code": logistic_regression_algorithm,
        "description": "Implementation of Logistic Regression for binary classification problems."
    },

    "Naive Bayes": {
        "code": naive_bayes_algorithm,
        "description": "Implementation of the Gaussian Naive Bayes classifier for classification tasks."
    },

    "Decision Tree Classifier": {
        "code": decision_tree_algorithm,
        "description": "Implementation of the Decision Tree algorithm for classification tasks."
    }
}

# Create the sidebar for navigation
st.sidebar.title("Algorithms")
selected_algorithm = st.sidebar.radio("Select an algorithm:", list(algorithms.keys()))

# Display the selected algorithm
st.header(selected_algorithm)
st.markdown(algorithms[selected_algorithm]["description"])

# Display the code with copy button
st.subheader("Code")
st.code(algorithms[selected_algorithm]["code"], language="python")

# Add a download button for the code
code_to_download = algorithms[selected_algorithm]["code"]
st.download_button(
    label="Download Code",
    data=code_to_download,
    file_name=f"{selected_algorithm.lower().replace(' ', '_')}.py",
    mime="text/plain"
)

# Add information about datasets
st.sidebar.markdown("---")
st.sidebar.subheader("Available Datasets")
datasets = [
    "Bank_Personal_Loan_Modelling.csv",
    "bank-full.csv",
    "Breastcancer_data.csv",
    "iris_csv (1).csv",
    "Naive-Bayes-Classification-Data.csv",
    "Social_Network_Ads.csv",
    "WA_Fn-UseC_-Telco-Customer-Churn.csv"
]

selected_dataset = st.sidebar.selectbox("Select a dataset:", datasets)

# Add dataset viewer
if selected_dataset:
    try:
        st.subheader(f"Dataset Preview: {selected_dataset}")
        # This is just a placeholder - in a real app, you would load the actual dataset
        st.info("In a full implementation, this would show a preview of the selected dataset.")
        st.markdown("To use this dataset in your code, you can load it with pandas:")
        st.code(f"import pandas as pd\ndf = pd.read_csv('{selected_dataset}')", language="python")
    except Exception as e:
        st.error(f"Error loading dataset: {e}")

# Footer
st.sidebar.markdown("---")
st.sidebar.info("AI & ML Lab Codes Collection - Created with Streamlit")
